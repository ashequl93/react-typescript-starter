'use client';

import { useEffect, useRef } from 'react';
import { signOut } from 'next-auth/react';

// Keys in localStorage
const LAST_ACTIVITY_KEY = 'idle.lastActivity';
const LOGOUT_ONCE_KEY = 'idle.logoutOnce';

// Read from env (string | undefined) -> number with safe fallback
const ENV_IDLE = Number(process.env.NEXT_PUBLIC_IDLE_TIMEOUT_MS);
const IDLE_LIMIT_MS: number =
  Number.isFinite(ENV_IDLE) && ENV_IDLE! > 0 ? ENV_IDLE! : 300_000; // default 5 minutes

// ---- Helpers (typed) ----
const now = (): number => Date.now();

const getLastActivity = (): number => {
  const v = localStorage.getItem(LAST_ACTIVITY_KEY);
  return v ? Number(v) : 0;
};

const setLastActivity = (t: number = now()): void => {
  const prev = getLastActivity();
  if (t > prev) localStorage.setItem(LAST_ACTIVITY_KEY, String(t));
};

const idleExceeded = (limitMs: number): boolean => {
  const last = getLastActivity();
  if (!last) return false;
  return now() - last >= limitMs;
};

const wasLoggedOutOnce = (): boolean =>
  localStorage.getItem(LOGOUT_ONCE_KEY) === '1';

const markLoggedOutOnce = (): void => {
  localStorage.setItem(LOGOUT_ONCE_KEY, '1');
};

// ---- Component ----
export default function IdleLogoutController(): null {
  // In the browser (DOM lib), setTimeout returns number
  const guardTimerRef = useRef<number | null>(null);

  useEffect(() => {
    // Seed baseline timestamp on first mount
    if (!getLastActivity()) setLastActivity();

    // If already beyond idle when mounting (e.g., laptop wake), sign out
    if (!wasLoggedOutOnce() && idleExceeded(IDLE_LIMIT_MS)) {
      markLoggedOutOnce();
      void signOut({ callbackUrl: '/login' });
      return;
    }

    // Any user activity: if timed out -> sign out; else update last activity
    const onActivity = (): void => {
      if (!wasLoggedOutOnce() && idleExceeded(IDLE_LIMIT_MS)) {
        markLoggedOutOnce();
        void signOut({ callbackUrl: '/login' });
        return;
      }
      setLastActivity();
    };

    // Periodic guard: catches long background idle (no events fired)
    const guardTick = (): void => {
      if (
        !wasLoggedOutOnce() &&
        document.visibilityState === 'visible' &&
        idleExceeded(IDLE_LIMIT_MS)
      ) {
        markLoggedOutOnce();
        void signOut({ callbackUrl: '/login' });
      }
      guardTimerRef.current = window.setTimeout(guardTick, 45_000);
    };
    guardTimerRef.current = window.setTimeout(guardTick, 45_000);

    // Cross-tab: if another tab logs out, mirror here
    const onStorage = (e: StorageEvent): void => {
      if (e.key === LOGOUT_ONCE_KEY && e.newValue === '1' && !wasLoggedOutOnce()) {
        markLoggedOutOnce();
        void signOut({ callbackUrl: '/login' });
      }
      // LAST_ACTIVITY_KEY updates are passively read via helpers when needed
    };

    // Treat focus/visibility as activity (also triggers sign-out if exceeded)
    const onFocus = (): void => onActivity();
    const onVisibilityChange = (): void => onActivity();

    // Record a final timestamp when leaving the page
    const onPageHide = (): void => setLastActivity();

    // Register listeners with strict types
    const windowEvents: Array<keyof WindowEventMap> = [
      'focus',
      'pagehide',
      'storage', // note: 'storage' is a WindowEvent (fires on *other* tabs)
    ];
    const activityWindowEvents: Array<keyof WindowEventMap> = [
      'pointerdown',
      'mousemove',
      'keydown',
      'wheel',
      'touchstart',
      'scroll',
    ];
    const documentEvents: Array<keyof DocumentEventMap> = ['visibilitychange'];

    // Activity listeners (window)
    activityWindowEvents.forEach((ev) =>
      window.addEventListener(ev, onActivity, { passive: true })
    );

    // Window listeners
    window.addEventListener('focus', onFocus);
    window.addEventListener('pagehide', onPageHide);
    window.addEventListener('storage', onStorage);

    // Document listeners
    document.addEventListener('visibilitychange', onVisibilityChange);

    // Cleanup
    return () => {
      if (guardTimerRef.current !== null) {
        clearTimeout(guardTimerRef.current);
      }
      activityWindowEvents.forEach((ev) =>
        window.removeEventListener(ev, onActivity as EventListenerOrEventListenerObject)
      );
      window.removeEventListener('focus', onFocus as EventListenerOrEventListenerObject);
      window.removeEventListener('pagehide', onPageHide as EventListenerOrEventListenerObject);
      window.removeEventListener('storage', onStorage as EventListenerOrEventListenerObject);
      document.removeEventListener(
        'visibilitychange',
        onVisibilityChange as EventListenerOrEventListenerObject
      );
    };
  }, []);

  return null;
}
