'use client';

import { useEffect, useRef } from 'react';
import { signOut } from 'next-auth/react';

// LocalStorage keys
const LAST_ACTIVITY_KEY = 'idle.lastActivity';
const LOGOUT_ONCE_KEY = 'idle.logoutOnce';

// Configurable idle limit (default 5 minutes)
const ENV_IDLE = Number(process.env.NEXT_PUBLIC_IDLE_TIMEOUT_MS);
const IDLE_LIMIT_MS: number =
  Number.isFinite(ENV_IDLE) && ENV_IDLE! > 0 ? ENV_IDLE! : 300_000;

// --- helpers (typed) ---
const now = (): number => Date.now();

const getLastActivity = (): number => {
  const v = localStorage.getItem(LAST_ACTIVITY_KEY);
  return v ? Number(v) : 0;
};

const setLastActivity = (t: number = now()): void => {
  const prev = getLastActivity();
  if (t > prev) localStorage.setItem(LAST_ACTIVITY_KEY, String(t));
};

const idleExceeded = (limitMs: number): boolean => {
  const last = getLastActivity();
  return !!last && now() - last >= limitMs;
};

const wasLoggedOutOnce = (): boolean =>
  localStorage.getItem(LOGOUT_ONCE_KEY) === '1';

const markLoggedOutOnce = (): void => {
  localStorage.setItem(LOGOUT_ONCE_KEY, '1');
};

// --- component ---
export default function IdleLogoutController(): null {
  const guardTimerRef = useRef<number | null>(null);

  useEffect(() => {
    // Initialize timestamp on first mount
    if (!getLastActivity()) setLastActivity();

    // If already idle (e.g., laptop wake), sign out immediately
    if (!wasLoggedOutOnce() && idleExceeded(IDLE_LIMIT_MS)) {
      markLoggedOutOnce();
      void signOut({ callbackUrl: '/login' });
      return;
    }

    const onActivity = (): void => {
      if (!wasLoggedOutOnce() && idleExceeded(IDLE_LIMIT_MS)) {
        markLoggedOutOnce();
        void signOut({ callbackUrl: '/login' });
        return;
      }
      setLastActivity();
    };

    // Periodic guard to catch long background periods (runs only when visible)
    const guardTick = (): void => {
      if (
        !wasLoggedOutOnce() &&
        document.visibilityState === 'visible' &&
        idleExceeded(IDLE_LIMIT_MS)
      ) {
        markLoggedOutOnce();
        void signOut({ callbackUrl: '/login' });
      }
      guardTimerRef.current = window.setTimeout(guardTick, 45_000);
    };
    guardTimerRef.current = window.setTimeout(guardTick, 45_000);

    // Cross-tab logout sync
    const onStorage = (e: StorageEvent): void => {
      if (e.key === LOGOUT_ONCE_KEY && e.newValue === '1' && !wasLoggedOutOnce()) {
        markLoggedOutOnce();
        void signOut({ callbackUrl: '/login' });
      }
    };

    // Treat focus/visibility as activity checkpoints
    const onFocus = (): void => onActivity();
    const onVisibilityChange = (): void => onActivity();

    // Record a final timestamp when leaving the page
    const onPageHide = (): void => setLastActivity();

    // Activity events (window)
    const activityWindowEvents: Array<keyof WindowEventMap> = [
      'pointerdown',
      'mousemove',
      'keydown',
      'wheel',
      'touchstart',
      'scroll',
    ];
    activityWindowEvents.forEach((ev) =>
      window.addEventListener(ev, onActivity, { passive: true })
    );

    // Window/document listeners
    window.addEventListener('focus', onFocus);
    window.addEventListener('pagehide', onPageHide);
    window.addEventListener('storage', onStorage);
    document.addEventListener('visibilitychange', onVisibilityChange);

    // Cleanup
    return () => {
      if (guardTimerRef.current !== null) {
        clearTimeout(guardTimerRef.current);
      }
      activityWindowEvents.forEach((ev) =>
        window.removeEventListener(ev, onActivity)
      );
      window.removeEventListener('focus', onFocus);
      window.removeEventListener('pagehide', onPageHide);
      window.removeEventListener('storage', onStorage);
      document.removeEventListener('visibilitychange', onVisibilityChange);
    };
  }, []);

  return null;
}
