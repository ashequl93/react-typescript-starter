'use client';

import { useEffect, useRef } from 'react';
import { signOut } from 'next-auth/react';

/**
 * Sliding idle timeout (industry standard):
 * - Cross-tab awareness via localStorage
 * - Signs out after true inactivity >= IDLE_LIMIT_MS
 * - Immediate sign-out on first activity after timeout OR on periodic guard tick
 * - No dependency on SessionProvider
 */

const LAST_ACTIVITY_KEY = 'idle.lastActivity';
const LOGOUT_ONCE_KEY = 'idle.logoutOnce';

// Configure via env if you like, with a safe default (5 minutes)
const IDLE_LIMIT_MS =
  Number(process.env.NEXT_PUBLIC_IDLE_TIMEOUT_MS ?? 300_000) || 300_000;

function now() {
  return Date.now();
}

function getLastActivity(): number {
  const v = localStorage.getItem(LAST_ACTIVITY_KEY);
  return v ? Number(v) : 0;
}

function setLastActivity(t = now()) {
  const prev = getLastActivity();
  if (t > prev) localStorage.setItem(LAST_ACTIVITY_KEY, String(t));
}

function idleExceeded(): boolean {
  const last = getLastActivity();
  if (!last) return false;
  return now() - last >= IDLE_LIMIT_MS;
}

function markLoggedOutOnce() {
  localStorage.setItem(LOGOUT_ONCE_KEY, '1');
}
function wasLoggedOutOnce() {
  return localStorage.getItem(LOGOUT_ONCE_KEY) === '1';
}

export default function IdleLogoutController() {
  const guardTimer = useRef<number | null>(null);

  useEffect(() => {
    // Seed baseline last-activity on first mount
    if (!getLastActivity()) setLastActivity();

    // If we already exceeded while the tab was sleeping, sign out now
    if (!wasLoggedOutOnce() && idleExceeded()) {
      markLoggedOutOnce();
      // callbackUrl -> your login page or landing page
      signOut({ callbackUrl: '/login' });
      return;
    }

    // Any user activity: if already timed out -> sign out; else reset last-activity
    const onActivity = () => {
      if (!wasLoggedOutOnce() && idleExceeded()) {
        markLoggedOutOnce();
        signOut({ callbackUrl: '/login' });
        return;
      }
      setLastActivity();
    };

    // Periodic guard: catches long background idle (no events fired)
    const tick = () => {
      if (!wasLoggedOutOnce() &&
          document.visibilityState === 'visible' &&
          idleExceeded()) {
        markLoggedOutOnce();
        signOut({ callbackUrl: '/login' });
      }
      // Run ~every 45s (low overhead, fast enough UX)
      guardTimer.current = window.setTimeout(tick, 45_000) as unknown as number;
    };
    guardTimer.current = window.setTimeout(tick, 45_000) as unknown as number;

    // Cross-tab sync: if another tab logs out, mirror here
    const onStorage = (e: StorageEvent) => {
      if (e.key === LOGOUT_ONCE_KEY && e.newValue === '1' && !wasLoggedOutOnce()) {
        markLoggedOutOnce();
        signOut({ callbackUrl: '/login' });
      }
      // LAST_ACTIVITY_KEY writes are passive; we just read them when needed
    };

    // Treat focus/visibility as "activity" moments (also triggers immediate sign-out if exceeded)
    const onFocus = onActivity;
    const onVisible = () => onActivity();

    // Record a final timestamp as we leave (helps avoid false idle across quick navigations)
    const onPageHide = () => setLastActivity();

    const activityEvents: (keyof DocumentEventMap | keyof WindowEventMap)[] = [
      'pointerdown', 'mousemove', 'keydown', 'wheel', 'touchstart', 'scroll'
    ];
    activityEvents.forEach(ev =>
      window.addEventListener(ev as any, onActivity, { passive: true })
    );
    window.addEventListener('focus', onFocus);
    document.addEventListener('visibilitychange', onVisible);
    window.addEventListener('pagehide', onPageHide);
    window.addEventListener('storage', onStorage);

    return () => {
      if (guardTimer.current) clearTimeout(guardTimer.current as unknown as number);
      activityEvents.forEach(ev =>
        window.removeEventListener(ev as any, onActivity as any)
      );
      window.removeEventListener('focus', onFocus);
      document.removeEventListener('visibilitychange', onVisible);
      window.removeEventListener('pagehide', onPageHide);
      window.removeEventListener('storage', onStorage);
    };
  }, []);

  return null;
}
