"use client";

import React, { useContext, useEffect, useRef } from "react";
import { GoogleMapContext } from "./googleMapContext";

type ControlPositionName =
  | "TOP_LEFT" | "TOP_CENTER" | "TOP_RIGHT"
  | "LEFT_TOP" | "RIGHT_TOP" | "LEFT_CENTER" | "RIGHT_CENTER"
  | "LEFT_BOTTOM" | "RIGHT_BOTTOM"
  | "BOTTOM_LEFT" | "BOTTOM_CENTER" | "BOTTOM_RIGHT";

type MapControlProps = {
  position: ControlPositionName | google.maps.ControlPosition;
  index?: number;
  disabled?: boolean;
  className?: string;
  children: React.ReactNode;
};

export function MapControl({
  position,
  index,
  disabled,
  className,
  children,
}: MapControlProps) {
  const map = useContext(GoogleMapContext);

  // React-owned node (no document.createElement, no portal)
  const containerRef = useRef<HTMLDivElement | null>(null);

  // Remember where we inserted it so we can remove/move safely
  const insertedPosRef = useRef<google.maps.ControlPosition | null>(null);

  useEffect(() => {
    const el = containerRef.current;
    if (!map) return;
    if (disabled) return;
    if (!el) return;
    if (!window.google?.maps?.ControlPosition) return;

    const normalizedPos =
      typeof position === "string"
        ? window.google.maps.ControlPosition[position]
        : position;

    if (normalizedPos === undefined) {
      console.error("Invalid control position:", position);
      return;
    }

    // If already inserted somewhere else, remove first
    if (insertedPosRef.current !== null && insertedPosRef.current !== normalizedPos) {
      const oldPos = insertedPosRef.current;
      const oldArr = map.controls[oldPos];
      const oldIdx = oldArr.getArray().indexOf(el);
      if (oldIdx >= 0) oldArr.removeAt(oldIdx);
      insertedPosRef.current = null;
    }

    // Insert if not already inserted
    if (insertedPosRef.current === null) {
      const arr = map.controls[normalizedPos];

      // Make it visible once inserted
      el.hidden = false;

      if (typeof index === "number") {
        const safeIndex = Math.max(0, Math.min(index, arr.getLength()));
        arr.insertAt(safeIndex, el);
      } else {
        arr.push(el);
      }

      insertedPosRef.current = normalizedPos;
    } else {
      // Already inserted at same position. If index changes, reposition.
      if (typeof index === "number") {
        const arr = map.controls[normalizedPos];
        const currentIdx = arr.getArray().indexOf(el);
        const desiredIdx = Math.max(0, Math.min(index, arr.getLength() - 1));

        if (currentIdx !== -1 && currentIdx !== desiredIdx) {
          arr.removeAt(currentIdx);
          arr.insertAt(desiredIdx, el);
        }
      }
    }

    return () => {
      const pos = insertedPosRef.current;
      if (pos === null) return;

      const arr = map.controls[pos];
      const i = arr.getArray().indexOf(el);
      if (i >= 0) arr.removeAt(i);

      insertedPosRef.current = null;

      // Hide again when removed
      el.hidden = true;
    };
  }, [map, disabled, position, index]);

  // If disabled, remove immediately if it was inserted (optional safety)
  useEffect(() => {
    const el = containerRef.current;
    if (!map) return;
    if (!el) return;

    if (!disabled) return;

    const pos = insertedPosRef.current;
    if (pos === null) return;

    const arr = map.controls[pos];
    const i = arr.getArray().indexOf(el);
    if (i >= 0) arr.removeAt(i);

    insertedPosRef.current = null;
    el.hidden = true;
  }, [disabled, map]);

  // Always render a host node (React controls children)
  return (
    <div ref={containerRef} className={className} hidden>
      {!disabled ? children : null}
    </div>
  );
}
